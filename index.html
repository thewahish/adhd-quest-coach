<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Quest Coach - Your ADHD-Friendly RPG Life System</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
            color: #333;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
        }

        /* Header Section */
        .header {
            background: rgba(255, 255, 255, 0.95);
            border-radius: 20px;
            padding: 30px;
            margin-bottom: 20px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
        }

        .header h1 {
            font-size: 2.5em;
            color: #667eea;
            margin-bottom: 10px;
        }

        .header .subtitle {
            color: #666;
            font-size: 1.1em;
        }

        /* Stats Dashboard */
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            margin-bottom: 20px;
        }

        .stat-card {
            background: rgba(255, 255, 255, 0.95);
            border-radius: 15px;
            padding: 25px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
            transition: transform 0.3s ease;
        }

        .stat-card:hover {
            transform: translateY(-5px);
        }

        .stat-card h3 {
            font-size: 0.9em;
            color: #888;
            text-transform: uppercase;
            margin-bottom: 10px;
        }

        .stat-value {
            font-size: 2.5em;
            font-weight: bold;
            color: #667eea;
            margin-bottom: 10px;
        }

        .progress-bar {
            height: 10px;
            background: #e0e0e0;
            border-radius: 10px;
            overflow: hidden;
            margin-top: 10px;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #667eea, #764ba2);
            border-radius: 10px;
            transition: width 0.5s ease;
        }

        /* Quest Section */
        .quest-section {
            background: rgba(255, 255, 255, 0.95);
            border-radius: 20px;
            padding: 30px;
            margin-bottom: 20px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
        }

        .quest-section h2 {
            color: #667eea;
            margin-bottom: 20px;
            font-size: 1.8em;
            border-bottom: 3px solid #667eea;
            padding-bottom: 10px;
        }

        .quest-list {
            list-style: none;
        }

        .quest-item {
            background: #f8f9fa;
            border-left: 5px solid #667eea;
            padding: 20px;
            margin-bottom: 15px;
            border-radius: 10px;
            display: flex;
            align-items: center;
            gap: 15px;
            transition: all 0.3s ease;
        }

        .quest-item:hover {
            background: #e9ecef;
            transform: translateX(5px);
        }

        .quest-item.completed {
            border-left-color: #28a745;
            opacity: 0.7;
        }

        .quest-item.urgent {
            border-left: 5px solid #dc3545;
            background: linear-gradient(135deg, #ffebee 0%, #fff5f5 100%);
            box-shadow: 0 3px 10px rgba(220, 53, 69, 0.3);
            position: relative;
        }

        .quest-item.urgent .quest-title {
            color: #c62828;
            font-weight: bold;
        }

        .quest-item.urgent::before {
            content: "ğŸš¨ URGENT";
            position: absolute;
            top: 10px;
            right: 10px;
            background: #dc3545;
            color: white;
            padding: 4px 10px;
            border-radius: 12px;
            font-size: 0.7em;
            font-weight: bold;
            letter-spacing: 0.5px;
        }

        .quest-item.locked {
            opacity: 0.5;
            background: #f5f5f5;
            cursor: not-allowed;
        }

        .quest-item.locked:hover {
            background: #f5f5f5;
            transform: none;
        }

        .quest-chain-indicator {
            display: inline-block;
            background: #667eea;
            color: white;
            padding: 2px 8px;
            border-radius: 10px;
            font-size: 0.75em;
            margin-left: 8px;
        }

        .quest-chain-locked {
            display: flex;
            align-items: center;
            gap: 5px;
            color: #888;
            font-size: 0.85em;
            margin-top: 5px;
        }

        .expand-chain-btn {
            background: transparent;
            border: 1px solid #667eea;
            color: #667eea;
            padding: 5px 12px;
            border-radius: 15px;
            font-size: 0.8em;
            cursor: pointer;
            transition: all 0.2s ease;
            margin-top: 8px;
        }

        .expand-chain-btn:hover {
            background: #667eea;
            color: white;
            transform: scale(1.05);
        }

        .quest-chain-list {
            margin-top: 15px;
            padding-left: 20px;
            border-left: 3px dashed #667eea;
            display: none;
        }

        .quest-chain-list.expanded {
            display: block;
            animation: slideDown 0.3s ease;
        }

        @keyframes slideDown {
            from {
                opacity: 0;
                max-height: 0;
            }
            to {
                opacity: 1;
                max-height: 500px;
            }
        }

        .chain-step {
            padding: 10px;
            margin: 8px 0;
            background: white;
            border-radius: 8px;
            border-left: 3px solid #ddd;
        }

        .chain-step.current {
            border-left-color: #667eea;
            background: #f0f4ff;
        }

        .chain-step.completed-step {
            border-left-color: #28a745;
            opacity: 0.7;
        }

        .chain-step.locked-step {
            opacity: 0.5;
            background: #f9f9f9;
        }

        .quest-icon {
            font-size: 2em;
            min-width: 50px;
            text-align: center;
        }

        .quest-content {
            flex: 1;
        }

        .quest-title {
            font-weight: bold;
            font-size: 1.1em;
            margin-bottom: 5px;
            color: #333;
        }

        .quest-category {
            font-size: 0.85em;
            color: #888;
            text-transform: uppercase;
        }

        .quest-checkbox {
            width: 30px;
            height: 30px;
            cursor: pointer;
        }

        /* Mood Tracker */
        .mood-section {
            background: rgba(255, 255, 255, 0.95);
            border-radius: 20px;
            padding: 30px;
            margin-bottom: 20px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
        }

        .mood-buttons {
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
            margin-top: 15px;
        }

        .mood-btn {
            font-size: 3em;
            border: none;
            background: #f8f9fa;
            padding: 20px;
            border-radius: 15px;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .mood-btn:hover {
            transform: scale(1.1);
            background: #e9ecef;
        }

        .mood-btn.selected {
            background: #667eea;
            transform: scale(1.15);
        }

        /* Input Section */
        .input-section {
            background: rgba(255, 255, 255, 0.95);
            border-radius: 20px;
            padding: 30px;
            margin-bottom: 20px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
        }

        textarea, input {
            width: 100%;
            padding: 15px;
            border: 2px solid #e0e0e0;
            border-radius: 10px;
            font-size: 1em;
            font-family: inherit;
            margin-top: 10px;
            resize: vertical;
        }

        textarea:focus, input:focus {
            outline: none;
            border-color: #667eea;
        }

        button {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 15px 30px;
            border-radius: 10px;
            font-size: 1.1em;
            cursor: pointer;
            margin-top: 15px;
            transition: all 0.3s ease;
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
        }

        /* Responsive - Mobile Optimized */
        @media (max-width: 768px) {
            body {
                padding: 10px;
            }

            .header {
                padding: 15px;
                margin-bottom: 15px;
            }

            .header h1 {
                font-size: 1.5em;
            }

            .header .subtitle {
                font-size: 0.9em;
            }

            /* Make stats compact on mobile - 2 columns */
            .stats-grid {
                grid-template-columns: repeat(2, 1fr);
                gap: 10px;
                margin-bottom: 15px;
            }

            .stat-card {
                padding: 15px;
            }

            .stat-card h3 {
                font-size: 0.7em;
                margin-bottom: 5px;
            }

            .stat-value {
                font-size: 1.5em;
            }

            .stat-card p {
                font-size: 0.7em;
                margin-top: 5px !important;
            }

            /* Quest sections */
            .quest-section, .mood-section, .input-section {
                padding: 15px;
                margin-bottom: 15px;
            }

            .quest-section h2, .mood-section h2, .input-section h2 {
                font-size: 1.3em;
                margin-bottom: 10px;
            }

            /* Quest items more compact */
            .quest-item {
                padding: 12px;
                margin-bottom: 10px;
            }

            .quest-icon {
                font-size: 1.5em;
                width: 40px;
                height: 40px;
                min-width: 40px;
            }

            .quest-title {
                font-size: 0.95em;
            }

            .quest-category {
                font-size: 0.75em;
            }

            .quest-item.urgent::before {
                font-size: 0.6em;
                padding: 3px 8px;
                top: 8px;
                right: 8px;
            }

            /* Buttons smaller on mobile */
            button {
                padding: 10px 15px !important;
                font-size: 0.85em !important;
            }

            .mood-btn {
                font-size: 1.8em;
                padding: 12px !important;
            }

            /* Category badges smaller */
            .category-badge {
                font-size: 0.65em;
                padding: 3px 8px;
            }

            /* Brain dump and inputs */
            textarea, input[type="text"] {
                font-size: 0.95em;
                padding: 12px;
            }

            /* Quest chain steps */
            .quest-chain-list {
                font-size: 0.85em;
            }

            .chain-step {
                padding: 8px;
            }

            /* Sync buttons container */
            .header > div {
                display: flex;
                flex-wrap: wrap;
                gap: 8px;
                margin-top: 10px;
            }

            .header button {
                flex: 1;
                min-width: 120px;
            }
        }

        .category-badge {
            display: inline-block;
            padding: 5px 10px;
            border-radius: 20px;
            font-size: 0.75em;
            font-weight: bold;
            margin-left: 10px;
        }

        .category-work {
            background: #e3f2fd;
            color: #1976d2;
        }

        .category-personal {
            background: #f3e5f5;
            color: #7b1fa2;
        }

        .category-health {
            background: #e8f5e9;
            color: #388e3c;
        }

        .category-urgent {
            background: #ffebee;
            color: #c62828;
        }

        .hidden {
            display: none;
        }

        /* Voice Input Styles */
        .voice-input-container {
            position: relative;
            margin-top: 10px;
        }

        .mic-button {
            position: absolute;
            right: 15px;
            bottom: 15px;
            width: 50px;
            height: 50px;
            border-radius: 50%;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border: none;
            color: white;
            font-size: 1.5em;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s ease;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.2);
        }

        .mic-button:hover {
            transform: scale(1.1);
            box-shadow: 0 6px 15px rgba(0, 0, 0, 0.3);
        }

        .mic-button.recording {
            background: linear-gradient(135deg, #dc3545 0%, #c82333 100%);
            animation: pulse 1.5s infinite;
        }

        @keyframes pulse {
            0%, 100% {
                transform: scale(1);
                box-shadow: 0 4px 10px rgba(220, 53, 69, 0.4);
            }
            50% {
                transform: scale(1.1);
                box-shadow: 0 6px 20px rgba(220, 53, 69, 0.6);
            }
        }

        .recording-indicator {
            display: none;
            background: #dc3545;
            color: white;
            padding: 10px 20px;
            border-radius: 10px;
            margin-top: 10px;
            text-align: center;
            font-weight: bold;
            animation: blink 1s infinite;
        }

        .recording-indicator.active {
            display: block;
        }

        @keyframes blink {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }

        .browser-support-warning {
            background: #fff3cd;
            color: #856404;
            padding: 10px;
            border-radius: 10px;
            margin-top: 10px;
            display: none;
        }
    </style>
</head>
<body>
    <div class="container">
        <!-- Header -->
        <div class="header">
            <div style="display: flex; justify-content: space-between; align-items: flex-start;">
                <div style="flex: 1;">
                    <h1>âš”ï¸ Quest Coach</h1>
                    <p class="subtitle">Your ADHD-Friendly RPG Life System</p>
                    <p class="subtitle" id="player-title">Level up one quest at a time, at your own pace</p>
                </div>
                <button id="toggle-sync-btn" onclick="toggleSyncControls()" style="background: #6c757d; padding: 8px 15px; font-size: 0.85em; border-radius: 50px; margin-top: 10px;">
                    âš™ï¸ Sync
                </button>
            </div>

            <!-- Quick Actions -->
            <div style="margin-top: 15px; display: flex; gap: 10px; flex-wrap: wrap; justify-content: center;">
                <button onclick="refreshQuestsClean()" style="background: #9c27b0; padding: 10px 20px; font-size: 0.9em;" title="Reload quests from code, remove duplicates, keep your progress">
                    ğŸ”„ Refresh Quests
                </button>
                <button onclick="exportForProjectSync()" style="background: #ff9800; padding: 10px 20px; font-size: 0.9em;" title="Download state to sync with project folders">
                    ğŸ“ Export Progress
                </button>
                <button onclick="toggleSyncLog()" style="background: #17a2b8; padding: 10px 20px; font-size: 0.9em;" title="View all sync attempts and their status">
                    ğŸ“Š Sync Log
                </button>
                <button onclick="toggleActivityLog()" style="background: #6c757d; padding: 10px 20px; font-size: 0.9em;" title="View all your activity">
                    ğŸ“œ Activity Log
                </button>
            </div>

            <!-- GitHub Sync Controls (Collapsible) -->
            <div id="sync-controls" style="margin-top: 20px; padding-top: 20px; border-top: 2px solid #e0e0e0; display: none; gap: 10px; align-items: center; flex-wrap: wrap; justify-content: center;">
                <button id="sync-push-btn" onclick="syncToGitHub()" style="background: #28a745; padding: 10px 20px; font-size: 0.9em;">
                    â¬†ï¸ Sync to GitHub
                </button>
                <button id="sync-pull-btn" onclick="syncFromGitHub()" style="background: #17a2b8; padding: 10px 20px; font-size: 0.9em;">
                    â¬‡ï¸ Load from GitHub
                </button>
                <button onclick="showSyncSettings()" style="background: #6c757d; padding: 10px 20px; font-size: 0.9em;">
                    âš™ï¸ Sync Settings
                </button>
                <span id="sync-status" style="color: #ffc107; font-size: 0.85em; margin-left: 10px;">
                    Not configured
                </span>
            </div>
        </div>

        <!-- Stats Dashboard -->
        <div class="stats-grid">
            <div class="stat-card">
                <h3>ğŸ¯ XP Points</h3>
                <div class="stat-value" id="xp-points">0</div>
                <div class="progress-bar">
                    <div class="progress-fill" id="xp-progress" style="width: 0%"></div>
                </div>
            </div>

            <div class="stat-card">
                <h3>ğŸ† Level</h3>
                <div class="stat-value" id="player-level">1</div>
                <p style="color: #888; margin-top: 10px;">Keep completing quests!</p>
            </div>

            <div class="stat-card">
                <h3>âœ… Quests Completed</h3>
                <div class="stat-value"><span id="completed-quests">0</span>/<span id="total-quests">0</span></div>
                <div class="progress-bar">
                    <div class="progress-fill" id="quest-progress" style="width: 0%"></div>
                </div>
            </div>

            <div class="stat-card">
                <h3>ğŸ”¥ Current Streak</h3>
                <div class="stat-value" id="streak">0</div>
                <p style="color: #888; margin-top: 10px;">days in a row</p>
            </div>
        </div>

        <!-- Mood Check -->
        <div class="mood-section">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                <h2 style="margin: 0;">ğŸ˜Š How are you feeling today?</h2>
                <button onclick="toggleMoodHistory()" style="background: #9c27b0; padding: 8px 15px; font-size: 0.85em;">
                    ğŸ“Š Mood Log
                </button>
            </div>
            <div id="current-mood-display" style="margin-bottom: 15px; padding: 10px; background: #e8f5e9; border-radius: 8px; display: none;">
                <strong>Current mood:</strong> <span id="current-mood-text"></span> <span id="current-mood-emoji" style="font-size: 1.5em;"></span>
                <small style="display: block; color: #666; margin-top: 5px;" id="current-mood-time"></small>
            </div>
            <p style="color: #666; margin-bottom: 10px;">Select your current mood:</p>
            <div class="mood-buttons">
                <button class="mood-btn" onclick="selectMood('amazing', 'ğŸ¤©')">ğŸ¤©</button>
                <button class="mood-btn" onclick="selectMood('good', 'ğŸ˜Š')">ğŸ˜Š</button>
                <button class="mood-btn" onclick="selectMood('okay', 'ğŸ˜')">ğŸ˜</button>
                <button class="mood-btn" onclick="selectMood('struggling', 'ğŸ˜”')">ğŸ˜”</button>
                <button class="mood-btn" onclick="selectMood('overwhelmed', 'ğŸ˜°')">ğŸ˜°</button>
            </div>
            <div id="mood-message" style="margin-top: 20px; padding: 15px; background: #f8f9fa; border-radius: 10px; display: none;">
                <p id="mood-text"></p>
            </div>
        </div>

        <!-- Mood History (Hidden by default) -->
        <div class="mood-section hidden" id="mood-history-section">
            <h2>ğŸ“Š Mood Log</h2>
            <p style="color: #666; margin-bottom: 15px;">Your mood check-ins over time</p>
            <div id="mood-history-list" style="max-height: 400px; overflow-y: auto;">
                <!-- Mood history will be populated here -->
            </div>
            <button onclick="toggleMoodHistory()" style="background: #6c757d; margin-top: 15px;">Close Mood Log</button>
        </div>

        <!-- Sync Log (Hidden by default) -->
        <div class="mood-section hidden" id="sync-log-section">
            <h2>ğŸ“Š Sync Log</h2>
            <p style="color: #666; margin-bottom: 15px;">All sync attempts to GitHub</p>
            <div id="sync-log-list" style="max-height: 400px; overflow-y: auto;">
                <!-- Sync log will be populated here -->
            </div>
            <button onclick="toggleSyncLog()" style="background: #6c757d; margin-top: 15px;">Close Sync Log</button>
        </div>

        <!-- Activity Log (Hidden by default) -->
        <div class="mood-section hidden" id="activity-log-section">
            <h2>ğŸ“œ Activity Log</h2>
            <p style="color: #666; margin-bottom: 15px;">All your activity and interactions</p>
            <div id="activity-log-list" style="max-height: 400px; overflow-y: auto;">
                <!-- Activity log will be populated here -->
            </div>
            <button onclick="toggleActivityLog()" style="background: #6c757d; margin-top: 15px;">Close Activity Log</button>
        </div>

        <!-- Active Quests -->
        <div class="quest-section">
            <h2>âš”ï¸ Active Quests</h2>
            <p style="color: #666; margin-bottom: 15px;">Focus on these right now. Keep it manageable!</p>
            <ul class="quest-list" id="quest-list">
                <!-- Quests will be populated here -->
            </ul>
            <button onclick="showAddQuest()">â• Add New Quest</button>
            <button onclick="toggleInventory()" style="background: #6c757d; margin-left: 10px;">ğŸ“¦ Quest Inventory (<span id="inventory-count">0</span>)</button>
            <button onclick="toggleCompleted()" style="background: #28a745; margin-left: 10px;">âœ… Completed (<span id="completed-count">0</span>)</button>
        </div>

        <!-- Quest Inventory (Hidden by default) -->
        <div class="quest-section hidden" id="inventory-section">
            <h2>ğŸ“¦ Quest Inventory</h2>
            <p style="color: #666; margin-bottom: 15px;">All your available quests. Pull them into Active when you have the stamina!</p>

            <!-- Filter buttons -->
            <div style="margin-bottom: 20px; display: flex; gap: 10px; flex-wrap: wrap;">
                <button onclick="filterInventory('all')" style="background: #6c757d; padding: 10px 20px; font-size: 0.9em;">All</button>
                <button onclick="filterInventory('urgent')" style="background: #dc3545; padding: 10px 20px; font-size: 0.9em;">ğŸš¨ Urgent</button>
                <button onclick="filterInventory('work')" style="background: #667eea; padding: 10px 20px; font-size: 0.9em;">ğŸ’¼ Work</button>
                <button onclick="filterInventory('awaiting_client')" style="background: #ffc107; padding: 10px 20px; font-size: 0.9em;">â³ Awaiting Client</button>
                <button onclick="filterInventory('planning')" style="background: #17a2b8; padding: 10px 20px; font-size: 0.9em;">ğŸ“‹ Planning</button>
            </div>

            <ul class="quest-list" id="inventory-list">
                <!-- Inventory quests will be populated here -->
            </ul>
            <button onclick="toggleInventory()" style="background: #6c757d;">Close Inventory</button>
        </div>

        <!-- Completed Quests (Hidden by default) -->
        <div class="quest-section hidden" id="completed-section">
            <h2>âœ… Completed Quests</h2>
            <p style="color: #666; margin-bottom: 15px;">Your victories! You crushed these quests. ğŸ‰</p>

            <ul class="quest-list" id="completed-list">
                <!-- Completed quests will be populated here -->
            </ul>
            <button onclick="toggleCompleted()" style="background: #28a745;">Close Completed</button>
        </div>

        <!-- Add Quest Section (Hidden by default) -->
        <div class="input-section hidden" id="add-quest-section">
            <h2>â• Add New Quest</h2>
            <input type="text" id="quest-title-input" placeholder="What quest do you want to tackle?">
            <select id="quest-category" style="margin-top: 15px; padding: 15px;">
                <option value="work">ğŸ’¼ Work</option>
                <option value="personal">ğŸ  Personal</option>
                <option value="health">â¤ï¸ Health</option>
                <option value="urgent">ğŸš¨ Urgent</option>
            </select>
            <div style="margin-top: 15px;">
                <button onclick="addQuest()">Add Quest</button>
                <button onclick="cancelAddQuest()" style="background: #6c757d;">Cancel</button>
            </div>
        </div>

        <!-- Brain Dump Section -->
        <div class="input-section">
            <h2>ğŸ§  Brain Dump</h2>
            <p style="color: #666; margin-bottom: 10px;">Got thoughts racing? Dump them here by typing or speaking. I'll help you organize them.</p>
            <div class="voice-input-container">
                <textarea id="brain-dump" rows="5" placeholder="Type or click the mic to speak..."></textarea>
                <button class="mic-button" id="mic-button" onclick="toggleVoiceInput()" title="Click to speak">ğŸ¤</button>
            </div>
            <div id="recording-indicator" class="recording-indicator">
                ğŸ”´ Recording... (Click mic again to stop)
            </div>
            <div id="browser-warning" class="browser-support-warning">
                Voice input not supported in your browser. Please use Chrome, Edge, or Safari.
            </div>
            <button onclick="processBrainDump()">Process Thoughts</button>

            <!-- Daily Progress Log -->
            <div style="margin-top: 15px;">
                <button onclick="toggleDailyProgressLog()" style="background: #28a745; padding: 8px 15px; font-size: 0.85em; border-radius: 50px;">
                    ğŸ“Š Daily Progress Log
                </button>
            </div>

            <div id="daily-progress-log" style="display: none; margin-top: 15px; padding: 15px; background: #f0f8ff; border-radius: 10px; max-height: 500px; overflow-y: auto;">
                <h3 style="margin-top: 0; color: #28a745;">ğŸ“Š Daily Progress Log</h3>
                <div style="margin-bottom: 10px;">
                    <select id="progress-date-filter" onchange="renderDailyProgress()" style="padding: 8px; border-radius: 5px; border: 1px solid #ddd;">
                        <option value="today">Today</option>
                        <option value="yesterday">Yesterday</option>
                        <option value="week">This Week</option>
                        <option value="all">All Time</option>
                    </select>
                </div>
                <div id="daily-progress-content"></div>
            </div>

            <!-- View Past Brain Dumps -->
            <div style="margin-top: 15px;">
                <button onclick="toggleBrainDumpHistory()" style="background: #6c757d; padding: 8px 15px; font-size: 0.85em; border-radius: 50px;">
                    ğŸ“œ View Past Brain Dumps (<span id="brain-dump-count">0</span>)
                </button>
            </div>

            <div id="brain-dump-history" style="display: none; margin-top: 15px; padding: 15px; background: #f8f9fa; border-radius: 10px; max-height: 400px; overflow-y: auto;">
                <h3 style="margin-top: 0; color: #667eea;">ğŸ“œ Brain Dump History</h3>
                <div id="brain-dump-list"></div>
                <button onclick="clearBrainDumps()" style="background: #dc3545; margin-top: 10px; padding: 8px 15px; font-size: 0.85em;">
                    ğŸ—‘ï¸ Clear All Brain Dumps
                </button>
            </div>
        </div>

        <!-- Daily Reflection (End of day) -->
        <div class="input-section">
            <h2>ğŸ“ Daily Reflection</h2>
            <p style="color: #666; margin-bottom: 10px;">Before you rest, let's reflect on your day:</p>
            <textarea id="daily-reflection" rows="4" placeholder="What went well today? What could be better tomorrow?"></textarea>
            <button onclick="saveReflection()">Save Reflection</button>

            <!-- View Past Reflections -->
            <div style="margin-top: 15px;">
                <button onclick="toggleReflectionHistory()" style="background: #9c27b0; padding: 8px 15px; font-size: 0.85em; border-radius: 50px;">
                    ğŸ“œ View Past Reflections (<span id="reflection-count">0</span>)
                </button>
            </div>

            <div id="reflection-history" style="display: none; margin-top: 15px; padding: 15px; background: #faf5ff; border-radius: 10px; max-height: 400px; overflow-y: auto;">
                <h3 style="margin-top: 0; color: #9c27b0;">ğŸ“œ Reflection History</h3>
                <div id="reflection-list"></div>
            </div>
        </div>
    </div>

    <!-- GitHub Sync Settings Modal -->
    <div id="sync-settings-modal" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.7); z-index: 10000; align-items: center; justify-content: center;">
        <div style="background: white; border-radius: 20px; padding: 40px; max-width: 600px; width: 90%; box-shadow: 0 20px 60px rgba(0,0,0,0.5);">
            <h2 style="color: #667eea; margin-bottom: 20px;">âš™ï¸ GitHub Sync Settings</h2>

            <div style="margin-bottom: 25px;">
                <h3 style="color: #333; font-size: 1.1em; margin-bottom: 10px;">ğŸ“ Setup Instructions:</h3>
                <ol style="color: #666; line-height: 1.8; margin-left: 20px;">
                    <li>Go to <a href="https://github.com/settings/tokens" target="_blank" style="color: #667eea;">GitHub Settings â†’ Developer settings â†’ Personal access tokens â†’ Tokens (classic)</a></li>
                    <li>Click "Generate new token (classic)"</li>
                    <li>Give it a name like "Quest Coach Sync"</li>
                    <li>Select scope: <strong>repo</strong> (full control of private repositories)</li>
                    <li>Click "Generate token"</li>
                    <li>Copy the token and paste it below</li>
                </ol>
            </div>

            <div style="margin-bottom: 20px;">
                <label style="display: block; color: #333; font-weight: bold; margin-bottom: 8px;">GitHub Personal Access Token:</label>
                <input type="password" id="github-token-input" placeholder="ghp_xxxxxxxxxxxx" style="width: 100%; padding: 12px; border: 2px solid #ddd; border-radius: 8px; font-size: 0.95em;">
                <div style="display: flex; gap: 10px; margin-top: 8px; align-items: center;">
                    <p style="color: #888; font-size: 0.85em; margin: 0;">ğŸ”’ Stored securely in your browser's localStorage</p>
                    <button type="button" onclick="showTokenMask()" style="background: #6c757d; padding: 5px 10px; font-size: 0.8em;">ğŸ‘ï¸ Show Token</button>
                </div>
                <p id="token-status" style="color: #28a745; font-size: 0.85em; margin-top: 5px; display: none;">âœ… Token already saved for this browser</p>
                <p style="color: #ff9800; font-size: 0.85em; margin-top: 8px; background: #fff3cd; padding: 8px; border-radius: 5px;">
                    âš ï¸ <strong>Important:</strong> Each browser/domain has separate storage. If you use both local file (file:///) and web (https://), you need to configure each separately.
                </p>
            </div>

            <div style="margin-bottom: 25px;">
                <label style="display: flex; align-items: center; color: #333; cursor: pointer;">
                    <input type="checkbox" id="auto-sync-checkbox" style="width: 20px; height: 20px; margin-right: 10px; cursor: pointer;">
                    <span>Enable auto-sync (syncs 5 seconds after each change)</span>
                </label>
            </div>

            <div style="display: flex; gap: 10px; justify-content: flex-end;">
                <button onclick="closeSyncSettings()" style="background: #6c757d; padding: 12px 25px;">
                    Cancel
                </button>
                <button onclick="saveSyncSettings()" style="background: #28a745; padding: 12px 25px;">
                    ğŸ’¾ Save Settings
                </button>
            </div>

            <div style="margin-top: 25px; padding-top: 20px; border-top: 2px solid #e0e0e0;">
                <h3 style="color: #333; font-size: 1em; margin-bottom: 10px;">ğŸ’¡ How it works:</h3>
                <ul style="color: #666; line-height: 1.8; margin-left: 20px; font-size: 0.9em;">
                    <li><strong>â¬†ï¸ Sync to GitHub:</strong> Pushes your current progress to GitHub (overwrites remote)</li>
                    <li><strong>â¬‡ï¸ Load from GitHub:</strong> Loads progress from GitHub (overwrites local)</li>
                    <li><strong>Auto-sync:</strong> Automatically pushes to GitHub 5 seconds after any change</li>
                    <li><strong>Result:</strong> Access same progress on all devices! ğŸ‰</li>
                </ul>
            </div>
        </div>
    </div>

    <!-- Include Quest Data -->
    <script src="all-projects-quests.js"></script>

    <!-- Initialize app state FIRST (before quest-importer needs it) -->
    <script>
        // Initialize app state (make it global so quest-importer can access it)
        window.appState = {
            xp: 0,
            level: 1,
            streak: 0,
            quests: [], // Active quests only
            inventory: [], // All available quests (not active)
            mood: null,
            lastActiveDate: null,
            brainDumps: [],
            reflections: [],

            // ğŸ“Š NEW: History tracking for stats/graphs
            history: {
                questCompletions: [],  // Track every quest completed
                levelUps: [],          // Track every level gained
                dailyStats: [],        // Track daily XP/progress
                moodCheckins: [],      // Track mood over time
                sessions: [],          // Track when you used Quest Coach
                syncLog: [],           // Track all sync attempts
                activityLog: []        // Track all activity (chat, edits, etc.)
            }
        };

        // Load state from localStorage
        function loadState() {
            const saved = localStorage.getItem('questCoachState');
            if (saved) {
                appState = JSON.parse(saved);
                updateUI();
                updateBrainDumpCount();
            } else {
                // Initialize with empty arrays - quest importer will populate from all-projects-quests.js
                appState.quests = [];
                appState.inventory = [];
                saveState();
            }
        }

        // Save state to localStorage
        function saveState() {
            localStorage.setItem('questCoachState', JSON.stringify(appState));
        }

        // Update all UI elements
        function updateUI() {
            // Update stats
            document.getElementById('xp-points').textContent = appState.xp;
            document.getElementById('player-level').textContent = appState.level;
            document.getElementById('streak').textContent = appState.streak;

            // Calculate quest completion
            const completed = appState.quests.filter(q => q.completed).length;
            const total = appState.quests.length;
            document.getElementById('completed-quests').textContent = completed;
            document.getElementById('total-quests').textContent = total;

            // Update progress bars
            const xpForNextLevel = appState.level * 100;
            const xpProgress = (appState.xp % xpForNextLevel) / xpForNextLevel * 100;
            document.getElementById('xp-progress').style.width = xpProgress + '%';

            const questProgress = total > 0 ? (completed / total * 100) : 0;
            document.getElementById('quest-progress').style.width = questProgress + '%';

            // Update quest list
            renderQuests();

            // Check for level up (prevent repeated calls)
            const currentLevelThreshold = appState.level * 100;
            if (appState.xp >= currentLevelThreshold) {
                // Calculate what level we should be at
                const calculatedLevel = Math.floor(appState.xp / 100) + 1;
                if (calculatedLevel > appState.level) {
                    levelUp();
                }
            }

            // Display current mood
            displayCurrentMood();
        }

        // Render quest list
        function renderQuests() {
            const questList = document.getElementById('quest-list');
            questList.innerHTML = '';

            // Filter out completed quests - they go to the completed section now
            const activeQuests = appState.quests.filter(q => !q.completed);

            // Sort: urgent first (check both category and priority)
            const sortedQuests = [...activeQuests].sort((a, b) => {
                const aIsUrgent = a.category === 'urgent' || a.priority === 'urgent';
                const bIsUrgent = b.category === 'urgent' || b.priority === 'urgent';

                if (aIsUrgent && !bIsUrgent) return -1;
                if (!aIsUrgent && bIsUrgent) return 1;
                return 0;
            });

            sortedQuests.forEach(quest => {
                // Check if quest is part of a chain and if it's locked
                const isLocked = isQuestLocked(quest);
                const chainInfo = getQuestChainInfo(quest);

                const li = document.createElement('li');
                const isUrgent = quest.category === 'urgent' || quest.priority === 'urgent';
                li.className = `quest-item ${quest.completed ? 'completed' : ''} ${isUrgent ? 'urgent' : ''} ${isLocked ? 'locked' : ''}`;

                let chainHTML = '';
                if (chainInfo.hasChain) {
                    chainHTML = `
                        <span class="quest-chain-indicator">ğŸ“Š Step ${chainInfo.currentStep}/${chainInfo.totalSteps}</span>
                        ${chainInfo.nextSteps.length > 0 ? `
                            <button class="expand-chain-btn" onclick="toggleChainExpansion(${quest.id})" id="chain-btn-${quest.id}">
                                â–¼ Show Next Steps (${chainInfo.nextSteps.length})
                            </button>
                            <div class="quest-chain-list" id="chain-${quest.id}">
                                ${chainInfo.nextSteps.map((step, idx) => `
                                    <div class="chain-step ${step.completed ? 'completed-step' : (idx === 0 ? 'current' : 'locked-step')}">
                                        <div style="display: flex; align-items: center; gap: 10px;">
                                            <span>${step.completed ? 'âœ…' : (idx === 0 ? 'ğŸ“' : 'ğŸ”’')}</span>
                                            <div style="flex: 1;">
                                                <div style="font-weight: ${idx === 0 ? 'bold' : 'normal'};">${step.title}</div>
                                                <small style="color: #888;">+${step.xpValue} XP</small>
                                            </div>
                                        </div>
                                    </div>
                                `).join('')}
                            </div>
                        ` : ''}
                    `;
                }

                let lockedHTML = '';
                if (isLocked && chainInfo.blockingQuest) {
                    lockedHTML = `
                        <div class="quest-chain-locked">
                            <span>ğŸ”’</span>
                            <span>Complete "<strong>${chainInfo.blockingQuest.title}</strong>" first</span>
                        </div>
                    `;
                }

                li.innerHTML = `
                    <div class="quest-icon">${quest.icon}</div>
                    <div class="quest-content" style="flex: 1;">
                        <div class="quest-title">
                            ${quest.title}
                            <span class="category-badge category-${quest.category}">${quest.category}</span>
                            ${chainHTML}
                        </div>
                        <div class="quest-category">
                            +${quest.xpValue} XP
                            ${quest.notes ? '<br><small style="color:#888;">' + quest.notes + '</small>' : ''}
                            ${lockedHTML}
                        </div>
                    </div>
                    <div style="display: flex; align-items: center; gap: 10px;">
                        <button onclick="deactivateQuest(${quest.id})"
                                style="padding: 5px 10px; font-size: 0.75em; background: #6c757d; color: white; border: none; border-radius: 5px; cursor: pointer;"
                                title="Move to inventory">
                            ğŸ“¦
                        </button>
                        <input type="checkbox" class="quest-checkbox" ${quest.completed ? 'checked' : ''} ${isLocked ? 'disabled' : ''}
                               onchange="toggleQuest(${quest.id})" title="${isLocked ? 'Complete previous quest first' : 'Mark as complete'}">
                    </div>
                `;
                questList.appendChild(li);
            });

            if (sortedQuests.length === 0) {
                questList.innerHTML = '<p style="text-align: center; color: #888; padding: 20px;">No active quests. Add one to get started!</p>';
            }
        }

        // Toggle chain expansion
        function toggleChainExpansion(questId) {
            const chainList = document.getElementById(`chain-${questId}`);
            const btn = document.getElementById(`chain-btn-${questId}`);

            if (chainList.classList.contains('expanded')) {
                chainList.classList.remove('expanded');
                btn.textContent = btn.textContent.replace('â–² Hide', 'â–¼ Show');
            } else {
                chainList.classList.add('expanded');
                btn.textContent = btn.textContent.replace('â–¼ Show', 'â–² Hide');
            }
        }

        // Check if quest is locked (requires previous quest completion)
        function isQuestLocked(quest) {
            if (!quest.requiresQuest) return false;

            // Find the required quest by questId (string)
            const requiredQuest = appState.quests.find(q => q.questId === quest.requiresQuest);
            if (!requiredQuest) {
                // Also check inventory
                const inventoryQuest = appState.inventory?.find(q => q.questId === quest.requiresQuest);
                return inventoryQuest ? !inventoryQuest.completed : false;
            }

            return !requiredQuest.completed;
        }

        // Get quest chain information
        function getQuestChainInfo(quest) {
            const info = {
                hasChain: false,
                currentStep: 1,
                totalSteps: 1,
                nextSteps: [],
                blockingQuest: null
            };

            // If quest has a chain property with next steps
            if (quest.questChain && Array.isArray(quest.questChain)) {
                info.hasChain = true;
                info.nextSteps = quest.questChain;
                info.totalSteps = 1 + quest.questChain.length;
                info.currentStep = 1;
            }

            // If quest requires another quest, find the blocking quest by questId
            if (quest.requiresQuest) {
                info.blockingQuest = appState.quests.find(q => q.questId === quest.requiresQuest) ||
                                    appState.inventory?.find(q => q.questId === quest.requiresQuest);
            }

            return info;
        }

        // Toggle quest completion
        function toggleQuest(questId) {
            const quest = appState.quests.find(q => q.id === questId);
            if (quest) {
                // Check if quest is locked
                if (isQuestLocked(quest) && !quest.completed) {
                    const chainInfo = getQuestChainInfo(quest);
                    if (chainInfo.blockingQuest) {
                        showNotification(`ğŸ”’ Complete "${chainInfo.blockingQuest.title}" first!`);
                    } else {
                        showNotification('ğŸ”’ This quest is locked. Complete the previous quest first!');
                    }
                    updateUI(); // Refresh to uncheck the checkbox
                    return;
                }

                quest.completed = !quest.completed;

                if (quest.completed) {
                    // Award XP
                    appState.xp += quest.xpValue;
                    let totalXP = quest.xpValue;

                    // ğŸ“Š Log completion to history
                    if (!appState.history) appState.history = { questCompletions: [], levelUps: [], dailyStats: [], moodCheckins: [], sessions: [] };
                    appState.history.questCompletions.push({
                        questId: quest.id,
                        questName: quest.title,
                        xpEarned: quest.xpValue,
                        category: quest.category,
                        completedAt: new Date().toISOString()
                    });

                    // Update daily stats
                    updateDailyStats(quest.xpValue, 1);

                    // ğŸ® GAMIFICATION: Check for achievements
                    if (typeof checkAchievements === 'function') {
                        const newAchievements = checkAchievements(appState);
                        newAchievements.forEach(achievement => {
                            appState.xp += achievement.xpBonus;
                            totalXP += achievement.xpBonus;
                            showAchievementPopup(achievement);
                        });
                    }

                    // ğŸ® GAMIFICATION: Combo system
                    if (typeof incrementCombo === 'function') {
                        const comboBonus = incrementCombo(quest.xpValue);
                        if (comboBonus > 0) {
                            appState.xp += comboBonus;
                            totalXP += comboBonus;
                        }
                    }

                    // ğŸ® GAMIFICATION: Quest complete animation
                    if (typeof showQuestCompleteAnimation === 'function') {
                        showQuestCompleteAnimation(totalXP);
                    } else {
                        showNotification(`ğŸ‰ Quest completed! +${totalXP} XP`);
                    }
                } else {
                    // Remove XP
                    appState.xp -= quest.xpValue;

                    // ğŸ“Š Remove from history if uncompleted
                    if (appState.history && appState.history.questCompletions) {
                        const index = appState.history.questCompletions.findIndex(
                            c => c.questId === quest.id && c.questName === quest.title
                        );
                        if (index > -1) {
                            appState.history.questCompletions.splice(index, 1);
                        }
                    }

                    // Update daily stats
                    updateDailyStats(-quest.xpValue, -1);
                }

                saveState();
                updateUI();
            }
        }

        // Refresh quests from code (clean import with progress preservation)
        function refreshQuestsClean() {
            if (!confirm('ğŸ”„ Refresh Quests\n\nThis will:\nâœ… Reload all quests from code\nâœ… Remove any duplicates\nâœ… Keep your XP, level, and progress\nâœ… Ensure urgent quests appear at top\n\nContinue?')) {
                return;
            }

            try {
                // Backup current progress
                const progressBackup = {
                    xp: appState.xp || 0,
                    level: appState.level || 1,
                    streak: appState.streak || 0,
                    completedQuests: [],
                    questProgress: {}
                };

                // Save which quests are completed
                appState.quests.forEach(quest => {
                    if (quest.completed) {
                        progressBackup.completedQuests.push({
                            title: quest.title,
                            questId: quest.questId,
                            completed: true
                        });
                    }

                    // Save subtask progress
                    if (quest.subtasks && quest.subtasks.length > 0) {
                        const completedSubtasks = quest.subtasks.filter(st => st.completed);
                        if (completedSubtasks.length > 0) {
                            progressBackup.questProgress[quest.title] = {
                                subtasks: quest.subtasks.map(st => ({
                                    title: st.title,
                                    completed: st.completed
                                }))
                            };
                        }
                    }
                });

                // Store backup
                sessionStorage.setItem('questProgressBackup', JSON.stringify(progressBackup));
                sessionStorage.setItem('autoRestore', 'true');

                // Clear and reload
                localStorage.clear();
                location.reload();

            } catch (err) {
                console.error('Error refreshing quests:', err);
                alert('âŒ Error refreshing quests. Check console for details.');
            }
        }

        // Level up
        function levelUp() {
            const xpForNextLevel = appState.level * 100;

            // Only level up if we have enough XP and haven't already leveled up
            if (appState.xp >= xpForNextLevel) {
                appState.level++;

                // ğŸ“Š Log level up to history
                if (!appState.history) appState.history = { questCompletions: [], levelUps: [], dailyStats: [], moodCheckins: [], sessions: [] };
                appState.history.levelUps.push({
                    level: appState.level,
                    totalXP: appState.xp,
                    leveledUpAt: new Date().toISOString()
                });

                saveState(); // ğŸ”§ Save the level increase!

                // ğŸ® GAMIFICATION: Level up celebration
                if (typeof showLevelUpCelebration === 'function') {
                    showLevelUpCelebration(appState.level);
                } else {
                    showNotification(`ğŸŠ LEVEL UP! You're now level ${appState.level}!`);
                    // Play success sound
                    const audio = new Audio('data:audio/wav;base64,UklGRnoGAABXQVZFZm10IBAAAAABAAEAQB8AAEAfAAABAAgAZGF0YQoGAACBhYqFbF1fdJivrJBhNjVgodDbq2EcBj+a2/LDciUFLIHO8tiJNwgZaLvt559NEAxQp+PwtmMcBjiR1/LMeSwFJHfH8N2QQAoUXrTp66hVFApGn+DyvmwhBCx+zPLTgjMGHm7A7+OZURE');
                    audio.volume = 0.5;
                    audio.play().catch(() => {});
                }

                // ğŸ® GAMIFICATION: Update rank title
                if (typeof updatePlayerTitle === 'function') {
                    updatePlayerTitle();
                }

                // Check if there's another level to gain
                const newXpForNextLevel = appState.level * 100;
                if (appState.xp >= newXpForNextLevel) {
                    // Recursive level up for multiple levels at once
                    setTimeout(() => levelUp(), 500);
                }
            }
        }

        // Log sync attempt
        function logSync(status, message, details = {}) {
            if (!appState.history) appState.history = {};
            if (!appState.history.syncLog) appState.history.syncLog = [];

            appState.history.syncLog.push({
                status: status, // 'success', 'failed', 'skipped'
                message: message,
                details: details,
                timestamp: new Date().toISOString()
            });

            // Keep only last 100 sync logs
            if (appState.history.syncLog.length > 100) {
                appState.history.syncLog = appState.history.syncLog.slice(-100);
            }

            saveState();
            console.log(`[SYNC LOG] ${status.toUpperCase()}: ${message}`, details);
        }

        // Log activity
        function logActivity(type, message, details = {}) {
            if (!appState.history) appState.history = {};
            if (!appState.history.activityLog) appState.history.activityLog = [];

            appState.history.activityLog.push({
                type: type, // 'brain_dump', 'quest_complete', 'mood_check', etc.
                message: message,
                details: details,
                timestamp: new Date().toISOString()
            });

            // Keep only last 200 activity logs
            if (appState.history.activityLog.length > 200) {
                appState.history.activityLog = appState.history.activityLog.slice(-200);
            }

            saveState();
            console.log(`[ACTIVITY] ${type}: ${message}`, details);
        }

        // Show notification
        function showNotification(message) {
            // Simple alert for now - can be enhanced with better UI
            alert(message);
        }

        // Select mood
        function selectMood(mood, emoji) {
            appState.mood = { mood, emoji, date: new Date().toISOString() };

            // ğŸ“Š Log mood check-in to history
            if (!appState.history) appState.history = { questCompletions: [], levelUps: [], dailyStats: [], moodCheckins: [], sessions: [] };
            appState.history.moodCheckins.push({
                mood: mood,
                emoji: emoji,
                timestamp: new Date().toISOString()
            });

            // Update button states
            document.querySelectorAll('.mood-btn').forEach(btn => {
                btn.classList.remove('selected');
            });
            event.target.classList.add('selected');

            // Show encouraging message based on mood
            const moodMessages = {
                'amazing': "That's fantastic! You're on fire today! ğŸ”¥ Let's tackle those quests!",
                'good': "Great to hear! Keep that positive energy going! âœ¨",
                'okay': "That's perfectly fine. Let's take it one step at a time. ğŸŒ±",
                'struggling': "I hear you. Let's focus on just ONE small thing today. You got this. ğŸ’ª",
                'overwhelmed': "It's okay to feel this way. Let's break things down into tiny, manageable pieces. Take a deep breath. ğŸ§˜"
            };

            const moodDiv = document.getElementById('mood-message');
            const moodText = document.getElementById('mood-text');
            moodText.textContent = moodMessages[mood];
            moodDiv.style.display = 'block';

            // Update last active date and streak
            const today = new Date().toDateString();
            const lastActive = appState.lastActiveDate ? new Date(appState.lastActiveDate).toDateString() : null;

            if (lastActive !== today) {
                const yesterday = new Date(Date.now() - 86400000).toDateString();
                if (lastActive === yesterday) {
                    appState.streak++;
                } else if (lastActive !== null) {
                    appState.streak = 1;
                } else {
                    appState.streak = 1;
                }
                appState.lastActiveDate = new Date().toISOString();
            }

            saveState();
            updateUI();
            displayCurrentMood(); // Update current mood display
        }

        // Display current mood on page load
        function displayCurrentMood() {
            if (appState.mood && appState.mood.mood) {
                const display = document.getElementById('current-mood-display');
                const moodText = document.getElementById('current-mood-text');
                const moodEmoji = document.getElementById('current-mood-emoji');
                const moodTime = document.getElementById('current-mood-time');

                moodText.textContent = appState.mood.mood;
                moodEmoji.textContent = appState.mood.emoji;

                // Format time
                const moodDate = new Date(appState.mood.date);
                const now = new Date();
                const diffHours = Math.floor((now - moodDate) / (1000 * 60 * 60));

                let timeText;
                if (diffHours < 1) {
                    timeText = 'Just now';
                } else if (diffHours < 24) {
                    timeText = `${diffHours} hour${diffHours > 1 ? 's' : ''} ago`;
                } else {
                    const diffDays = Math.floor(diffHours / 24);
                    timeText = `${diffDays} day${diffDays > 1 ? 's' : ''} ago`;
                }

                moodTime.textContent = `Logged ${timeText}`;
                display.style.display = 'block';
            }
        }

        // Toggle mood history visibility
        function toggleMoodHistory() {
            const historySection = document.getElementById('mood-history-section');
            historySection.classList.toggle('hidden');

            if (!historySection.classList.contains('hidden')) {
                renderMoodHistory();
            }
        }

        // Render mood history
        function renderMoodHistory() {
            const historyList = document.getElementById('mood-history-list');

            if (!appState.history || !appState.history.moodCheckins || appState.history.moodCheckins.length === 0) {
                historyList.innerHTML = '<p style="text-align: center; color: #888; padding: 20px;">No mood check-ins yet. Log your first mood!</p>';
                return;
            }

            // Sort by most recent first
            const sorted = [...appState.history.moodCheckins].reverse();

            historyList.innerHTML = sorted.map((entry, index) => {
                const date = new Date(entry.timestamp);
                const dateStr = date.toLocaleDateString('en-US', {
                    month: 'short',
                    day: 'numeric',
                    year: 'numeric'
                });
                const timeStr = date.toLocaleTimeString('en-US', {
                    hour: 'numeric',
                    minute: '2-digit',
                    hour12: true
                });

                const moodColors = {
                    'amazing': '#4caf50',
                    'good': '#8bc34a',
                    'okay': '#ffc107',
                    'struggling': '#ff9800',
                    'overwhelmed': '#f44336'
                };

                return `
                    <div style="padding: 12px; margin-bottom: 10px; background: ${moodColors[entry.mood]}15; border-left: 4px solid ${moodColors[entry.mood]}; border-radius: 8px;">
                        <div style="display: flex; justify-content: space-between; align-items: center;">
                            <div>
                                <span style="font-size: 1.8em; margin-right: 10px;">${entry.emoji}</span>
                                <strong style="text-transform: capitalize;">${entry.mood}</strong>
                            </div>
                            <div style="text-align: right; font-size: 0.85em; color: #666;">
                                <div>${dateStr}</div>
                                <div>${timeStr}</div>
                            </div>
                        </div>
                    </div>
                `;
            }).join('');
        }

        // Toggle sync log visibility
        function toggleSyncLog() {
            const logSection = document.getElementById('sync-log-section');
            logSection.classList.toggle('hidden');

            if (!logSection.classList.contains('hidden')) {
                renderSyncLog();
            }
        }

        // Render sync log
        function renderSyncLog() {
            const logList = document.getElementById('sync-log-list');

            if (!appState.history || !appState.history.syncLog || appState.history.syncLog.length === 0) {
                logList.innerHTML = '<p style="text-align: center; color: #888; padding: 20px;">No sync attempts yet.</p>';
                return;
            }

            // Sort by most recent first
            const sorted = [...appState.history.syncLog].reverse();

            logList.innerHTML = sorted.map((entry) => {
                const date = new Date(entry.timestamp);
                const dateStr = date.toLocaleDateString('en-US', {
                    month: 'short',
                    day: 'numeric',
                    year: 'numeric'
                });
                const timeStr = date.toLocaleTimeString('en-US', {
                    hour: 'numeric',
                    minute: '2-digit',
                    hour12: true
                });

                const statusColors = {
                    'success': '#28a745',
                    'failed': '#dc3545',
                    'skipped': '#ffc107'
                };

                const statusEmojis = {
                    'success': 'âœ…',
                    'failed': 'âŒ',
                    'skipped': 'â­ï¸'
                };

                return `
                    <div style="padding: 12px; margin-bottom: 10px; background: ${statusColors[entry.status]}15; border-left: 4px solid ${statusColors[entry.status]}; border-radius: 8px;">
                        <div style="display: flex; justify-content: space-between; align-items: center;">
                            <div>
                                <span style="font-size: 1.3em; margin-right: 10px;">${statusEmojis[entry.status]}</span>
                                <strong style="text-transform: capitalize;">${entry.status}</strong>
                            </div>
                            <div style="text-align: right; font-size: 0.85em; color: #666;">
                                <div>${dateStr}</div>
                                <div>${timeStr}</div>
                            </div>
                        </div>
                        <div style="margin-top: 8px; color: #333; font-size: 0.9em;">${entry.message}</div>
                        ${entry.details && entry.details.trigger ? `<div style="margin-top: 4px; font-size: 0.8em; color: #888;">Trigger: ${entry.details.trigger}</div>` : ''}
                        ${entry.details && entry.details.commitUrl ? `<div style="margin-top: 4px; font-size: 0.8em;"><a href="${entry.details.commitUrl}" target="_blank" style="color: #667eea;">View commit</a></div>` : ''}
                        ${entry.details && entry.details.error ? `<div style="margin-top: 4px; font-size: 0.8em; color: #dc3545;">Error: ${entry.details.error}</div>` : ''}
                    </div>
                `;
            }).join('');
        }

        // Toggle activity log visibility
        function toggleActivityLog() {
            const logSection = document.getElementById('activity-log-section');
            logSection.classList.toggle('hidden');

            if (!logSection.classList.contains('hidden')) {
                renderActivityLog();
            }
        }

        // Render activity log
        function renderActivityLog() {
            const logList = document.getElementById('activity-log-list');

            if (!appState.history || !appState.history.activityLog || appState.history.activityLog.length === 0) {
                logList.innerHTML = '<p style="text-align: center; color: #888; padding: 20px;">No activity logged yet.</p>';
                return;
            }

            // Sort by most recent first
            const sorted = [...appState.history.activityLog].reverse();

            logList.innerHTML = sorted.map((entry) => {
                const date = new Date(entry.timestamp);
                const dateStr = date.toLocaleDateString('en-US', {
                    month: 'short',
                    day: 'numeric',
                    year: 'numeric'
                });
                const timeStr = date.toLocaleTimeString('en-US', {
                    hour: 'numeric',
                    minute: '2-digit',
                    hour12: true
                });

                const typeIcons = {
                    'brain_dump': 'ğŸ’­',
                    'quest_complete': 'âœ…',
                    'mood_check': 'ğŸ˜Š',
                    'reflection': 'ğŸ“',
                    'quest_add': 'â•',
                    'quest_delete': 'ğŸ—‘ï¸'
                };

                const typeColors = {
                    'brain_dump': '#667eea',
                    'quest_complete': '#28a745',
                    'mood_check': '#fbbf24',
                    'reflection': '#9c27b0',
                    'quest_add': '#17a2b8',
                    'quest_delete': '#dc3545'
                };

                return `
                    <div style="padding: 12px; margin-bottom: 10px; background: ${typeColors[entry.type] || '#6c757d'}15; border-left: 4px solid ${typeColors[entry.type] || '#6c757d'}; border-radius: 8px;">
                        <div style="display: flex; justify-content: space-between; align-items: center;">
                            <div>
                                <span style="font-size: 1.3em; margin-right: 10px;">${typeIcons[entry.type] || 'ğŸ“‹'}</span>
                                <strong>${entry.message}</strong>
                            </div>
                            <div style="text-align: right; font-size: 0.85em; color: #666;">
                                <div>${dateStr}</div>
                                <div>${timeStr}</div>
                            </div>
                        </div>
                        ${entry.details && Object.keys(entry.details).length > 0 ? `
                            <div style="margin-top: 8px; font-size: 0.85em; color: #666;">
                                ${JSON.stringify(entry.details, null, 2).replace(/[{}]/g, '').split('\n').filter(l => l.trim()).join('<br>')}
                            </div>
                        ` : ''}
                    </div>
                `;
            }).join('');
        }

        // Show add quest section
        function showAddQuest() {
            document.getElementById('add-quest-section').classList.remove('hidden');
        }

        // Cancel add quest
        function cancelAddQuest() {
            document.getElementById('add-quest-section').classList.add('hidden');
            document.getElementById('quest-title-input').value = '';
        }

        // Add new quest
        function addQuest() {
            const title = document.getElementById('quest-title-input').value.trim();
            const category = document.getElementById('quest-category').value;

            if (!title) {
                alert('Please enter a quest title!');
                return;
            }

            const categoryIcons = {
                'work': 'ğŸ’¼',
                'personal': 'ğŸ ',
                'health': 'â¤ï¸',
                'urgent': 'ğŸš¨'
            };

            const xpValues = {
                'work': 75,
                'personal': 50,
                'health': 100,
                'urgent': 50
            };

            const newQuest = {
                id: Date.now(),
                title: title,
                category: category,
                completed: false,
                xpValue: xpValues[category],
                icon: categoryIcons[category]
            };

            appState.quests.push(newQuest);
            saveState();
            updateUI();
            cancelAddQuest();
            showNotification('âœ… New quest added!');
        }

        // Voice input functionality
        let recognition = null;
        let isRecording = false;

        // Initialize speech recognition
        function initSpeechRecognition() {
            // Check browser support
            const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;

            if (!SpeechRecognition) {
                document.getElementById('browser-warning').style.display = 'block';
                document.getElementById('mic-button').style.display = 'none';
                return false;
            }

            recognition = new SpeechRecognition();
            recognition.continuous = true;
            recognition.interimResults = true;
            recognition.lang = 'en-US';

            let finalTranscript = '';

            recognition.onstart = function() {
                console.log('Speech recognition started');
                isRecording = true;
            };

            recognition.onresult = function(event) {
                let interimTranscript = '';

                for (let i = event.resultIndex; i < event.results.length; i++) {
                    const transcript = event.results[i][0].transcript;
                    if (event.results[i].isFinal) {
                        finalTranscript += transcript + ' ';
                    } else {
                        interimTranscript += transcript;
                    }
                }

                // Update textarea with transcript
                const textarea = document.getElementById('brain-dump');
                const currentText = textarea.value;

                // Only update if there's new content
                if (finalTranscript) {
                    textarea.value = currentText + finalTranscript;
                    finalTranscript = '';

                    // Auto-scroll to bottom
                    textarea.scrollTop = textarea.scrollHeight;
                }
            };

            recognition.onerror = function(event) {
                console.error('Speech recognition error:', event.error);
                if (event.error === 'no-speech') {
                    // Don't stop recording for no-speech error
                    return;
                }

                // Handle network errors with helpful message
                if (event.error === 'network') {
                    stopRecording();
                    alert('âš ï¸ Voice input needs internet connection.\n\nChrome uses Google Speech API which requires internet.\n\nCheck:\nâœ“ WiFi/internet is connected\nâœ“ VPN isn\'t blocking Google services\nâœ“ Try refreshing the page\n\nğŸ’¡ You can type instead!');
                    return;
                }

                // Handle other errors
                stopRecording();
                alert('Error with voice input: ' + event.error + '\n\nYou can still type your thoughts!');
            };

            recognition.onend = function() {
                if (isRecording) {
                    // Restart if user didn't manually stop
                    try {
                        recognition.start();
                    } catch (e) {
                        console.log('Recognition ended');
                    }
                }
            };

            return true;
        }

        // Toggle voice input
        function toggleVoiceInput() {
            if (!recognition) {
                const initialized = initSpeechRecognition();
                if (!initialized) return;
            }

            if (isRecording) {
                stopRecording();
            } else {
                startRecording();
            }
        }

        // Start recording
        function startRecording() {
            try {
                recognition.start();
                isRecording = true;

                // Update UI
                document.getElementById('mic-button').classList.add('recording');
                document.getElementById('recording-indicator').classList.add('active');

                // Focus textarea
                document.getElementById('brain-dump').focus();

                console.log('Recording started successfully');
            } catch (e) {
                console.error('Error starting recognition:', e);
                alert('Could not start voice input: ' + e.message + '\n\nMake sure you:\n1. Granted microphone permission\n2. Are using Chrome, Edge, or Safari\n3. Have a working microphone');
                stopRecording();
            }
        }

        // Stop recording
        function stopRecording() {
            if (recognition) {
                recognition.stop();
            }
            isRecording = false;

            // Update UI
            document.getElementById('mic-button').classList.remove('recording');
            document.getElementById('recording-indicator').classList.remove('active');
        }

        // === INVENTORY SYSTEM ===

        let currentInventoryFilter = 'all';

        // Toggle inventory visibility
        function toggleInventory() {
            const inventorySection = document.getElementById('inventory-section');
            inventorySection.classList.toggle('hidden');

            if (!inventorySection.classList.contains('hidden')) {
                renderInventory();
            }
        }

        // Render inventory quests
        function renderInventory() {
            const inventoryList = document.getElementById('inventory-list');
            const inventoryCount = document.getElementById('inventory-count');

            inventoryCount.textContent = appState.inventory.length;

            inventoryList.innerHTML = '';

            let filtered = appState.inventory;

            // Apply filter
            if (currentInventoryFilter !== 'all') {
                if (currentInventoryFilter === 'urgent') {
                    filtered = appState.inventory.filter(q => q.priority === 'urgent');
                } else if (currentInventoryFilter === 'awaiting_client' || currentInventoryFilter === 'planning') {
                    filtered = appState.inventory.filter(q => q.status === currentInventoryFilter);
                } else {
                    filtered = appState.inventory.filter(q => q.category === currentInventoryFilter);
                }
            }

            // Sort by priority
            const priorityOrder = { 'urgent': 0, 'high': 1, 'medium': 2, 'low': 3 };
            filtered.sort((a, b) => {
                return priorityOrder[a.priority] - priorityOrder[b.priority];
            });

            filtered.forEach(quest => {
                const li = document.createElement('li');
                const statusEmoji = {
                    'active': 'â–¶ï¸',
                    'awaiting_client': 'â³',
                    'planning': 'ğŸ“‹',
                    'blocked': 'ğŸš«'
                };

                const priorityBadge = quest.priority === 'urgent' ? '<span style="background:#dc3545;color:white;padding:2px 8px;border-radius:10px;font-size:0.75em;margin-left:5px;">URGENT</span>' : '';

                li.className = `quest-item`;
                li.innerHTML = `
                    <div class="quest-icon">${quest.icon}</div>
                    <div class="quest-content">
                        <div class="quest-title">
                            ${quest.title}
                            ${priorityBadge}
                        </div>
                        <div class="quest-category">
                            ${statusEmoji[quest.status] || ''} ${quest.status.replace('_', ' ')} â€¢ +${quest.xpValue} XP
                            ${quest.notes ? '<br><small style="color:#888;">' + quest.notes + '</small>' : ''}
                        </div>
                    </div>
                    <button onclick="activateQuest(${quest.id})" style="padding: 8px 15px; font-size: 0.85em; background: #28a745;">
                        â¬†ï¸ Activate
                    </button>
                `;
                inventoryList.appendChild(li);
            });

            if (filtered.length === 0) {
                inventoryList.innerHTML = '<p style="text-align: center; color: #888; padding: 20px;">No quests match this filter.</p>';
            }
        }

        // Filter inventory
        function filterInventory(filter) {
            currentInventoryFilter = filter;
            renderInventory();
        }

        // Move quest from inventory to active
        function activateQuest(questId) {
            const questIndex = appState.inventory.findIndex(q => q.id === questId);
            if (questIndex > -1) {
                const quest = appState.inventory.splice(questIndex, 1)[0];
                appState.quests.push(quest);
                saveState();
                updateUI();
                renderInventory();
                showNotification(`âœ… "${quest.title}" activated! Let's do this!`);
            }
        }

        // Move quest from active to inventory
        function deactivateQuest(questId) {
            const questIndex = appState.quests.findIndex(q => q.id === questId);
            if (questIndex > -1) {
                const quest = appState.quests.splice(questIndex, 1)[0];
                quest.completed = false; // Reset completion when moving to inventory
                appState.inventory.push(quest);
                saveState();
                updateUI();
                showNotification(`ğŸ“¦ "${quest.title}" moved to inventory.`);
            }
        }

        // Update the updateUI function to include inventory count and completed count
        const originalUpdateUI = updateUI;
        updateUI = function() {
            if (typeof originalUpdateUI === 'function') {
                originalUpdateUI();
            }

            // Update inventory count
            const inventoryCount = document.getElementById('inventory-count');
            if (inventoryCount) {
                inventoryCount.textContent = appState.inventory ? appState.inventory.length : 0;
            }

            // Update completed count
            const completedCount = document.getElementById('completed-count');
            if (completedCount) {
                const completedQuests = appState.quests.filter(q => q.completed);
                completedCount.textContent = completedQuests.length;
            }

            // Render inventory if visible
            const inventorySection = document.getElementById('inventory-section');
            if (inventorySection && !inventorySection.classList.contains('hidden')) {
                renderInventory();
            }

            // Render completed if visible
            const completedSection = document.getElementById('completed-section');
            if (completedSection && !completedSection.classList.contains('hidden')) {
                renderCompletedQuests();
            }
        };

        // === COMPLETED QUESTS SYSTEM ===

        // Toggle completed quests visibility
        function toggleCompleted() {
            const completedSection = document.getElementById('completed-section');
            completedSection.classList.toggle('hidden');

            if (!completedSection.classList.contains('hidden')) {
                renderCompletedQuests();
            }
        }

        // Render completed quests
        function renderCompletedQuests() {
            const completedList = document.getElementById('completed-list');
            const completedCount = document.getElementById('completed-count');

            // Get completed quests from appState.quests
            const completedQuests = appState.quests.filter(q => q.completed);

            completedCount.textContent = completedQuests.length;
            completedList.innerHTML = '';

            // Sort by completion (most recent first if we had timestamps)
            completedQuests.forEach(quest => {
                const li = document.createElement('li');
                li.className = 'quest-item completed';
                li.innerHTML = `
                    <div class="quest-icon">${quest.icon}</div>
                    <div class="quest-content">
                        <div class="quest-title">
                            ${quest.title}
                        </div>
                        <div class="quest-category">
                            âœ… Completed â€¢ +${quest.xpValue} XP
                            ${quest.notes ? '<br><small style="color:#888;">' + quest.notes + '</small>' : ''}
                        </div>
                    </div>
                    <button onclick="uncompleteQuest(${quest.id})" style="padding: 8px 15px; font-size: 0.85em; background: #ffc107;">
                        â†©ï¸ Undo
                    </button>
                `;
                completedList.appendChild(li);
            });

            if (completedQuests.length === 0) {
                completedList.innerHTML = '<p style="text-align: center; color: #888; padding: 20px;">No completed quests yet. Complete some quests to see them here!</p>';
            }
        }

        // Uncomplete a quest (move back to active)
        function uncompleteQuest(questId) {
            const quest = appState.quests.find(q => q.id === questId);
            if (quest) {
                quest.completed = false;
                // Remove XP that was awarded
                appState.xp -= quest.xpValue;
                if (appState.xp < 0) appState.xp = 0;
                saveState();
                updateUI();
                renderCompletedQuests();
                showNotification(`â†©ï¸ "${quest.title}" moved back to active quests.`);
            }
        }

        // === END COMPLETED QUESTS SYSTEM ===

        // === END INVENTORY SYSTEM ===

        // Process brain dump
        async function processBrainDump() {
            // Stop recording if active
            if (isRecording) {
                stopRecording();
            }

            const dump = document.getElementById('brain-dump').value.trim();

            if (!dump) {
                alert('Please write or speak something first!');
                return;
            }

            appState.brainDumps.push({
                content: dump,
                date: new Date().toISOString()
            });

            // Log activity
            logActivity('brain_dump', 'Brain dump saved', { contentLength: dump.length });

            saveState();

            alert('ğŸ’­ Brain dump saved! Take a deep breath. We\'ll organize this together.');
            document.getElementById('brain-dump').value = '';

            // Automatically push to GitHub after brain dump
            if (window.githubSync && window.githubSync.isConfigured()) {
                try {
                    console.log('Auto-syncing brain dump to GitHub...');
                    const questData = JSON.parse(localStorage.getItem('questCoachState'));
                    const result = await window.githubSync.pushToGitHub(questData);

                    // Log successful sync
                    logSync('success', 'Brain dump synced to GitHub', {
                        trigger: 'brain_dump_auto',
                        commitUrl: result.commitUrl
                    });

                    // Use showSyncNotification if available, otherwise fallback to showNotification
                    if (typeof showSyncNotification === 'function') {
                        showSyncNotification('âœ… Brain dump synced to GitHub!', 'success');
                    } else {
                        showNotification('âœ… Brain dump synced to GitHub!');
                    }
                    console.log('GitHub sync successful:', result);
                } catch (error) {
                    console.error('Auto-sync failed:', error);

                    // Log failed sync
                    logSync('failed', 'GitHub sync failed: ' + error.message, {
                        trigger: 'brain_dump_auto',
                        error: error.message
                    });

                    if (typeof showSyncNotification === 'function') {
                        showSyncNotification('âš ï¸ Brain dump saved locally, but GitHub sync failed', 'warning');
                    } else {
                        showNotification('âš ï¸ Brain dump saved locally, but GitHub sync failed. Use manual sync.');
                    }
                }
            } else {
                console.log('GitHub sync not configured - brain dump saved locally only');

                // Log that sync was skipped
                logSync('skipped', 'GitHub sync not configured', {
                    trigger: 'brain_dump_auto',
                    reason: 'no_token'
                });

                if (typeof showSyncNotification === 'function') {
                    showSyncNotification('ğŸ’¾ Brain dump saved locally (GitHub sync not configured)', 'warning');
                } else {
                    showNotification('ğŸ’¾ Saved locally. Configure GitHub sync in settings to auto-sync.');
                }
            }
        }

        // Toggle brain dump history visibility
        function toggleBrainDumpHistory() {
            const historySection = document.getElementById('brain-dump-history');
            historySection.style.display = historySection.style.display === 'none' ? 'block' : 'none';

            if (historySection.style.display === 'block') {
                renderBrainDumpHistory();
            }
        }

        // Render brain dump history
        function renderBrainDumpHistory() {
            const listContainer = document.getElementById('brain-dump-list');
            const brainDumps = appState.brainDumps || [];

            if (brainDumps.length === 0) {
                listContainer.innerHTML = '<p style="color: #999; font-style: italic;">No brain dumps yet. Start dumping your thoughts above!</p>';
                return;
            }

            // Sort by date, newest first
            const sortedDumps = [...brainDumps].reverse();

            listContainer.innerHTML = sortedDumps.map((dump, index) => {
                const date = new Date(dump.date);
                const dateStr = date.toLocaleDateString('en-US', { month: 'short', day: 'numeric', year: 'numeric' });
                const timeStr = date.toLocaleTimeString('en-US', { hour: 'numeric', minute: '2-digit' });

                return `
                    <div style="background: white; padding: 12px; margin-bottom: 10px; border-radius: 8px; border-left: 4px solid #667eea;">
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 5px;">
                            <span style="font-size: 0.85em; color: #667eea; font-weight: 600;">${dateStr} at ${timeStr}</span>
                            <button onclick="deleteBrainDump(${brainDumps.length - 1 - index})" style="background: #dc3545; padding: 4px 8px; font-size: 0.75em; border-radius: 4px;">Delete</button>
                        </div>
                        <p style="margin: 0; color: #333; line-height: 1.5; white-space: pre-wrap;">${dump.content}</p>
                    </div>
                `;
            }).join('');
        }

        // Delete a single brain dump
        function deleteBrainDump(index) {
            if (!confirm('Delete this brain dump?')) return;

            appState.brainDumps.splice(index, 1);
            saveState();
            renderBrainDumpHistory();
            updateBrainDumpCount();
            showNotification('Brain dump deleted');
        }

        // Clear all brain dumps
        function clearBrainDumps() {
            if (!confirm('Delete ALL brain dumps? This cannot be undone!')) return;

            appState.brainDumps = [];
            saveState();
            renderBrainDumpHistory();
            updateBrainDumpCount();
            showNotification('All brain dumps cleared');
        }

        // Update brain dump count
        function updateBrainDumpCount() {
            const countElement = document.getElementById('brain-dump-count');
            if (countElement) {
                countElement.textContent = (appState.brainDumps || []).length;
            }
        }

        // Toggle daily progress log
        function toggleDailyProgressLog() {
            const progressSection = document.getElementById('daily-progress-log');
            progressSection.style.display = progressSection.style.display === 'none' ? 'block' : 'none';

            if (progressSection.style.display === 'block') {
                renderDailyProgress();
            }
        }

        // Render daily progress
        function renderDailyProgress() {
            const filter = document.getElementById('progress-date-filter').value;
            const contentDiv = document.getElementById('daily-progress-content');

            const now = new Date();
            const todayStart = new Date(now.getFullYear(), now.getMonth(), now.getDate());
            const yesterdayStart = new Date(todayStart);
            yesterdayStart.setDate(yesterdayStart.getDate() - 1);
            const weekStart = new Date(todayStart);
            weekStart.setDate(weekStart.getDate() - 7);

            // Filter completed quests
            const completedQuests = (appState.quests || []).filter(q => q.completed);
            const filteredQuests = completedQuests.filter(q => {
                if (!q.completedDate) return false;
                const questDate = new Date(q.completedDate);

                switch(filter) {
                    case 'today': return questDate >= todayStart;
                    case 'yesterday': return questDate >= yesterdayStart && questDate < todayStart;
                    case 'week': return questDate >= weekStart;
                    default: return true;
                }
            });

            // Filter brain dumps
            const filteredBrainDumps = (appState.brainDumps || []).filter(dump => {
                const dumpDate = new Date(dump.date);

                switch(filter) {
                    case 'today': return dumpDate >= todayStart;
                    case 'yesterday': return dumpDate >= yesterdayStart && dumpDate < todayStart;
                    case 'week': return dumpDate >= weekStart;
                    default: return true;
                }
            });

            // Filter reflections
            const filteredReflections = (appState.reflections || []).filter(ref => {
                const refDate = new Date(ref.date);

                switch(filter) {
                    case 'today': return refDate >= todayStart;
                    case 'yesterday': return refDate >= yesterdayStart && refDate < todayStart;
                    case 'week': return refDate >= weekStart;
                    default: return true;
                }
            });

            // Calculate XP
            const totalXP = filteredQuests.reduce((sum, q) => sum + (q.xp || 0), 0);

            // Build HTML
            let html = `
                <div style="background: white; padding: 15px; border-radius: 8px; margin-bottom: 15px;">
                    <h4 style="margin: 0 0 10px 0; color: #667eea;">ğŸ“ˆ Summary</h4>
                    <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 10px; text-align: center;">
                        <div>
                            <div style="font-size: 24px; font-weight: bold; color: #28a745;">${filteredQuests.length}</div>
                            <div style="font-size: 0.85em; color: #666;">Quests Completed</div>
                        </div>
                        <div>
                            <div style="font-size: 24px; font-weight: bold; color: #fbbf24;">${totalXP}</div>
                            <div style="font-size: 0.85em; color: #666;">XP Earned</div>
                        </div>
                        <div>
                            <div style="font-size: 24px; font-weight: bold; color: #667eea;">${filteredBrainDumps.length}</div>
                            <div style="font-size: 0.85em; color: #666;">Brain Dumps</div>
                        </div>
                    </div>
                </div>
            `;

            // Completed quests
            if (filteredQuests.length > 0) {
                html += `
                    <div style="background: white; padding: 15px; border-radius: 8px; margin-bottom: 15px;">
                        <h4 style="margin: 0 0 10px 0; color: #28a745;">âœ… Completed Quests</h4>
                        ${filteredQuests.map(q => {
                            const completedDate = new Date(q.completedDate);
                            return `
                                <div style="padding: 8px; margin-bottom: 8px; background: #f0fdf4; border-left: 3px solid #28a745; border-radius: 4px;">
                                    <div style="font-weight: 500; color: #333;">${q.title}</div>
                                    <div style="font-size: 0.85em; color: #666;">
                                        ${completedDate.toLocaleDateString()} at ${completedDate.toLocaleTimeString(undefined, {hour: 'numeric', minute: '2-digit'})} â€¢ +${q.xp || 0} XP
                                    </div>
                                </div>
                            `;
                        }).join('')}
                    </div>
                `;
            }

            // Brain dumps
            if (filteredBrainDumps.length > 0) {
                html += `
                    <div style="background: white; padding: 15px; border-radius: 8px; margin-bottom: 15px;">
                        <h4 style="margin: 0 0 10px 0; color: #667eea;">ğŸ’­ Brain Dumps</h4>
                        ${filteredBrainDumps.map(dump => {
                            const dumpDate = new Date(dump.date);
                            return `
                                <div style="padding: 8px; margin-bottom: 8px; background: #eff6ff; border-left: 3px solid #667eea; border-radius: 4px;">
                                    <div style="font-size: 0.85em; color: #667eea; margin-bottom: 4px;">
                                        ${dumpDate.toLocaleDateString()} at ${dumpDate.toLocaleTimeString(undefined, {hour: 'numeric', minute: '2-digit'})}
                                    </div>
                                    <div style="color: #333; font-size: 0.9em;">${dump.content}</div>
                                </div>
                            `;
                        }).join('')}
                    </div>
                `;
            }

            // Reflections
            if (filteredReflections.length > 0) {
                html += `
                    <div style="background: white; padding: 15px; border-radius: 8px;">
                        <h4 style="margin: 0 0 10px 0; color: #92278F;">ğŸ“ Reflections</h4>
                        ${filteredReflections.map(ref => {
                            const refDate = new Date(ref.date);
                            return `
                                <div style="padding: 8px; margin-bottom: 8px; background: #faf5ff; border-left: 3px solid #92278F; border-radius: 4px;">
                                    <div style="font-size: 0.85em; color: #92278F; margin-bottom: 4px;">
                                        ${refDate.toLocaleDateString()}
                                    </div>
                                    <div style="color: #333; font-size: 0.9em;">${ref.content}</div>
                                </div>
                            `;
                        }).join('')}
                    </div>
                `;
            }

            if (filteredQuests.length === 0 && filteredBrainDumps.length === 0 && filteredReflections.length === 0) {
                html = '<p style="color: #999; font-style: italic; text-align: center; padding: 20px;">No activity for this time period yet.</p>';
            }

            contentDiv.innerHTML = html;
        }

        // Save daily reflection
        function saveReflection() {
            const reflection = document.getElementById('daily-reflection').value.trim();

            if (!reflection) {
                alert('Please write your reflection first!');
                return;
            }

            appState.reflections.push({
                content: reflection,
                date: new Date().toISOString()
            });

            // Log activity
            logActivity('reflection', 'Daily reflection saved', { contentLength: reflection.length });

            saveState();
            updateReflectionCount();

            alert('ğŸ“ Reflection saved! Rest well, you did great today! ğŸŒ™');
            document.getElementById('daily-reflection').value = '';
        }

        // Toggle reflection history
        function toggleReflectionHistory() {
            const historySection = document.getElementById('reflection-history');
            historySection.style.display = historySection.style.display === 'none' ? 'block' : 'none';

            if (historySection.style.display === 'block') {
                renderReflectionHistory();
            }
        }

        // Render reflection history
        function renderReflectionHistory() {
            const listContainer = document.getElementById('reflection-list');
            const reflections = appState.reflections || [];

            if (reflections.length === 0) {
                listContainer.innerHTML = '<p style="color: #999; font-style: italic;">No reflections yet. Save your first one above!</p>';
                return;
            }

            // Sort by date, newest first
            const sortedReflections = [...reflections].reverse();

            listContainer.innerHTML = sortedReflections.map((ref, index) => {
                const date = new Date(ref.date);
                const dateStr = date.toLocaleDateString('en-US', { month: 'short', day: 'numeric', year: 'numeric' });
                const timeStr = date.toLocaleTimeString('en-US', { hour: 'numeric', minute: '2-digit' });

                return `
                    <div style="background: white; padding: 12px; margin-bottom: 10px; border-radius: 8px; border-left: 4px solid #9c27b0;">
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 5px;">
                            <span style="font-size: 0.85em; color: #9c27b0; font-weight: 600;">${dateStr} at ${timeStr}</span>
                            <button onclick="deleteReflection(${reflections.length - 1 - index})" style="background: #dc3545; padding: 4px 8px; font-size: 0.75em; border-radius: 4px;">Delete</button>
                        </div>
                        <p style="margin: 0; color: #333; line-height: 1.5; white-space: pre-wrap;">${ref.content}</p>
                    </div>
                `;
            }).join('');
        }

        // Delete a reflection
        function deleteReflection(index) {
            if (!confirm('Delete this reflection?')) return;

            appState.reflections.splice(index, 1);
            saveState();
            renderReflectionHistory();
            updateReflectionCount();
            showNotification('Reflection deleted');
        }

        // Update reflection count
        function updateReflectionCount() {
            const countElement = document.getElementById('reflection-count');
            if (countElement) {
                countElement.textContent = (appState.reflections || []).length;
            }
        }

        // ğŸ“Š Update daily stats helper
        function updateDailyStats(xpChange, questsChange) {
            if (!appState.history) appState.history = { questCompletions: [], levelUps: [], dailyStats: [], moodCheckins: [], sessions: [] };

            const today = new Date().toISOString().split('T')[0]; // YYYY-MM-DD
            let todayStats = appState.history.dailyStats.find(s => s.date === today);

            if (!todayStats) {
                // Create new entry for today
                todayStats = {
                    date: today,
                    xpEarned: 0,
                    questsCompleted: 0,
                    mood: appState.mood ? appState.mood.mood : null,
                    brainDumps: appState.brainDumps ? appState.brainDumps.filter(d =>
                        d.date && d.date.startsWith(today)
                    ).length : 0
                };
                appState.history.dailyStats.push(todayStats);
            }

            // Update stats
            todayStats.xpEarned += xpChange;
            todayStats.questsCompleted += questsChange;

            // Keep only last 365 days of stats (to prevent storage bloat)
            if (appState.history.dailyStats.length > 365) {
                appState.history.dailyStats = appState.history.dailyStats.slice(-365);
            }
        }

        // ğŸ“Š Log session (when user opens Quest Coach)
        function logSession() {
            if (!appState.history) appState.history = { questCompletions: [], levelUps: [], dailyStats: [], moodCheckins: [], sessions: [] };

            appState.history.sessions.push({
                startTime: new Date().toISOString(),
                level: appState.level,
                xp: appState.xp,
                activeQuests: appState.quests ? appState.quests.length : 0
            });

            // Keep only last 100 sessions (to prevent storage bloat)
            if (appState.history.sessions.length > 100) {
                appState.history.sessions = appState.history.sessions.slice(-100);
            }

            saveState();
        }

        // === PROJECT FOLDER SYNC ===

        // Export state for syncing to project folders
        function exportForProjectSync() {
            // Download state file
            if (window.githubSync && typeof window.githubSync.exportStateForProjectSync === 'function') {
                window.githubSync.exportStateForProjectSync(appState);
            } else {
                // Fallback: manual download
                const stateJSON = JSON.stringify(appState, null, 2);
                const blob = new Blob([stateJSON], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = 'quest-coach-state.json';
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
            }

            // Show instructions
            const instructions = `ğŸ“ Project Sync Instructions:

1. âœ… Downloaded: quest-coach-state.json

2. Run this command in terminal:
   cd /Volumes/Ai/Projects/adhd-quest-coach
   node sync-projects-cli.js ~/Downloads/quest-coach-state.json

3. This will create/update quest-status.json in each project folder with:
   - Completed quests from Quest Coach
   - XP earned per project
   - Sync timestamps

4. Each project's quest-status.json tracks what's done!

ğŸ’¡ Your quest completions will now sync to individual project folders!`;

            alert(instructions);

            showNotification('âœ… State file downloaded! Check your Downloads folder.');
        }

        // Initialize app on load
        document.addEventListener('DOMContentLoaded', function() {
            loadState();

            // Update counts on page load
            updateReflectionCount();

            // ğŸ“Š Log this session
            logSession();
        });
    </script>

    <!-- Load external scripts AFTER appState is initialized -->
    <script src="github-sync.js"></script>
    <script src="quest-importer.js"></script>
    <script src="gamification.js"></script>
</body>
</html>
